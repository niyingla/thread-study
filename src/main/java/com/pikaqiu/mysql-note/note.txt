

B tree
1 叶子结点只存数据，非叶子节点也存数据也存主键。
2 主键从左到右升序排序，大节点在上层，每一个p(指针)都指向一个范围。
3 每个节点最少m个孩子，不是叶子节点至少两个，节点之间没有链表。
读取过程 加载磁盘块数据，然后内存查找，有数据直接返回，在下一层根据p(指针)，加载下一个磁盘块继续查找。

B+ tree
1 只有主键值，数据都在叶子节点。（inodb默认存储引擎，数据加大同样会影响数据高度，不存数据一定程度减小高度）
2 每个叶子结点之间都有双向链指针。
3 有两个头指针 1 树的根节点 2 叶子的根节点 （常驻内存）
B+ tree 两种实现 聚簇索引（叶子结点是行数据） 和 辅助索引 （叶子结点是主键）
B+并不限制是几叉树 （也就是子节点个数 根据当前节点主键范围数来判断几叉）

Hash（稀疏结构）不适合聚簇索引 只适合极少数具体值查询
使用时一般所有key 都会放在内存 会占用内存很大 但是这种情况redis更合适哦
频繁查询数据 会在内存建立lru缓存 会效率高一点（效果没那么好）


mvcc 每条数据和每个事务都有自己的版本号，当事务修改了某条数据，那么这个版本号就给到了对应行。
事务只能读到行版本号小于等于当前事务版本号的的。

mysql 锁（以下锁 最好带上主键不然就会锁表）
1 共享锁 select * from table_a for share 这时候允许其他读（for share），不允许其他for update
2 互斥锁 select * from table_a for update 不允许其他 （for share），也不允许其他for update